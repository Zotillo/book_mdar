Life On The Edge With Merb, DataMapper & RSpec
=================================================

- [Life On The Edge With Merb, DataMapper & RSpec](#contents_anchor_1)
- [Forward](#contents_anchor_2)
- [Preface](#contents_anchor_3)
- [What is Merb, DataMapper & RSpec?](#contents_anchor_4)
    - [Merb](#contents_anchor_5)
    - [Datamapper](#contents_anchor_6)
    - [RSpec](#contents_anchor_7)
- [What About Ruby On Rails?](#contents_anchor_8)
- [Communities](#contents_anchor_9)
    - [Websites](#contents_anchor_10)
    - [IRC Channels - freenode.net](#contents_anchor_11)
    - [Mailing Lists](#contents_anchor_12)
    - [Bug Trackers](#contents_anchor_13)
- [Getting Started](#contents_anchor_14)
    - [Installing Merb](#contents_anchor_15)
    - [Installing Datamapper](#contents_anchor_16)
    - [Install RSpec](#contents_anchor_17)
- [Creating an App](#contents_anchor_18)
    - [Configuring Merb](#contents_anchor_19)
- [The Framework](#contents_anchor_20)
- [A little blog](#contents_anchor_21)
    - [Models](#contents_anchor_22)
        - [Getting started](#contents_anchor_23)
            - [Properties](#contents_anchor_24)
            - [Associations](#contents_anchor_25)
                - [Polymorphic associations](#contents_anchor_26)
                - [Where is my has_many :through?!](#contents_anchor_27)
            - [Validation](#contents_anchor_28)
            - [Callbacks](#contents_anchor_29)
            - [Migrations](#contents_anchor_30)
        - [CRUD](#contents_anchor_31)
            - [Creating](#contents_anchor_32)
            - [Reading (aka finding)](#contents_anchor_33)
                - [Count](#contents_anchor_34)
                - [Each](#contents_anchor_35)
            - [Updating](#contents_anchor_36)
            - [Destroying](#contents_anchor_37)
    - [Routing](#contents_anchor_38)
    - [Controllers](#contents_anchor_39)
    - [Views](#contents_anchor_40)
        - [Partials](#contents_anchor_41)
    - [Mailers](#contents_anchor_42)
    - [Authentication](#contents_anchor_43)
    - [Attachments](#contents_anchor_44)
- [RSpec](#contents_anchor_45)
        - [What is it?](#contents_anchor_46)
        - [Why test?](#contents_anchor_47)
        - [What to test?](#contents_anchor_48)
    - [mocking](#contents_anchor_49)
    - [Helpers](#contents_anchor_50)
    - [Spec'ing Models](#contents_anchor_51)
    - [Spec'ing Views](#contents_anchor_52)
    - [Spec'ing Controllers](#contents_anchor_53)
        - [Getting started](#contents_anchor_54)
        - [Testing multipart forms](#contents_anchor_55)
    - [Caching](#contents_anchor_56)
- [Gotchas](#contents_anchor_57)
    - [Merb](#contents_anchor_58)
    - [DataMapper](#contents_anchor_59)
    - [RSpec](#contents_anchor_60)
- [Submitting a patch](#contents_anchor_61)
        - [Diffs](#contents_anchor_62)
        - [Docs](#contents_anchor_63)
        - [Specs](#contents_anchor_64)
- [Hacking Merb](#contents_anchor_65)
    - [ ](#contents_anchor_66)
    - [Changing the directory structure](#contents_anchor_67)
- [Deploying a Merb App](#contents_anchor_68)

# Life On The Edge With Merb, DataMapper & RSpec
# Forward

(TODO) the forward
# Preface

At New Bamboo we've been building our internal applications in Merb for quite some time now. This is a collaborative effort to document the features of Merb and DataMapper, while also providing an example Merb application.  

___Who is this for?___

The target reader is someone who has some experience with writing Ruby on Rails applications, and is looking to try out a new framework. So if your looking for the [AWDR](http://www.pragprog.com/titles/rails2) equivalent for Merb, you may be disappointed as not all topics will be covered.


Copyright &copy; 2008 Matthew Ford. All rights reserved. 

With generous contributions from:

* Andy Kent - Caching, book formatting and layout
* Damien Tanner - A Little blog
* Ben Reubenstein - Deployment
* (add your name)

<br />
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/uk/">Creative Commons Attribution-Noncommercial 2.0 UK: England & Wales License</a>.<a rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/uk/">

<img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/2.0/uk/88x31.png" />
</a>

Source code is dual licensed under the MIT and GPL licenses:

* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html




# What is Merb, DataMapper & RSpec?

> If you're not living on the edge, you're taking up too much room. - Alice Bartlett

Merb (Mongrel + ERB), DataMapper and RSpec are all open source projects, which can be used for building kick-ass web applications. As they are in active development, it can be hard to keep up, but we'll try our best to keep up to date.

## Merb

Merb is a bit like Ruby on Rails, as they both are frameworks for building web applications. It's a relatively new framework and was created by [Ezra Zygmuntowicz](http://brainspl.at/).

If you know Ruby and have used Rails you're likely to get the hang of Merb quite easily. Where Merb differs the most from Rails is it's approach to modularisation, it's not tied down to a particular ORM for example so you can use any one you wish.

This means the core of Merb is simple with additional functionality provided by plugins (gems).

Merb is actually made up of two gems, merb-core and merb-more. This is so you can pick and choose the functionality you need, the gem merb installs both merb-core and merb-more so you can get started straight away.

You might be wondering what's the benefit of this? Well merb-core can be used as an upload server, provide an api or as simple web app (a la [camping](http://code.whytheluckystiff.net/camping/)) where the functionality of a fully fledged framework isn't necessary. It also supports the [rack webserver interface](http://rack.rubyforge.org/) so you can use any web server that has rack support (mongrel, thin, etc.) 

## Datamapper

DataMapper is a Object-Relational Mapper (ORM) written in Ruby, created by Sam Smoot and is what we'll be using with Merb, you could use the same ORM Rails uses (ActiveRecord), but as there are plenty of examples of using ActiveRecord already I've chosen to use DataMapper.

It has some nice features which makes it faster than ActiveRecord in some cases, but what really stands out for me is the way it handles database attributes. The schema, migrations and attributes are all defined in one place, your model. So you no longer have to look around in your database or other files to see what is defined.

DataMapper has some similarities with ActiveRecord but we will highlight the differences as we go along.

## RSpec

(TODO) intro to RSpec
# What About Ruby On Rails?

> [Merb is] Harder, Better, Faster, Stronger, to quote Daft Punk - Max Williams

So what's the big deal, we have Ruby on Rails and that's enough isn't it? There is little to no doubt that Ruby on Rails has rocked the web application development world. You have to give credit where credit's due, but it can be unforgiving if you don't want to do things 'the Rails way'.
 
Where Rails is opinionated, Merb is agonistic. You can easily use your favourite ORM (ActiveRecord, DataMapper, Sequel, etc.), Javascript Library and template language.

Merb also has super-fast routing and is thread-safe (If performant were a word, Merb would be it). The core functionality is kept separate from the other plugins and it uses less Ruby 'magic', which makes it easy to understand.

Rails has received a lot of criticism for not being suitable for large scale web applications, which isn't necessarily true, but the Merb development team has set out to prove that Ruby is a viable language for building fast and scaleable web applications.

At the end of the day it's about choice, there are many new Ruby frameworks springing up, undoubtedly helped by the success of Rails, but in my opinion Merb shows the most promise.

If you'd like to take a look at some other frameworks these links should get you started:

- http://camping.rubyforge.org/files/README.html
- http://www.nitroproject.org/ 
- http://ramaze.rubyforge.org/
- http://sinatra.rubyforge.org/
- http://halcyon.rubyforge.org/
- http://wisteria.swiftcore.org/

# Communities

None of this would be possible without the help of the fantastic communities around these open source projects so instead of being tucked away in the appendix here is how to get involved with them.

## Websites

These are the first places to go for help, check out the apis and see if you can find your answer there.

* http://merbivore.com/
* http://datamapper.org/
* http://rspec.info/

## IRC Channels - freenode.net

If you can't find what you were looking for in the apis then you could join the respective irc channel and ask your question in there. 

* #merb
* #datamapper
* #rspec

## Mailing Lists

The mailing lists are another good way to get help, the response time isn't as fast as asking in an irc channel but it can be useful to do a search to see if someone else has had your problem before.

* http://groups.google.com/group/merb/
* http://groups.google.com/group/datamapper/
* http://rubyforge.org/pipermail/rspec-users/

## Bug Trackers

Your problem may or may not be a known bug, search the bug trackers and submit a ticket if its not there already (don't forget to include a description and test cases - even better a patch!).

* http://merb.devjavu.com/
* http://wm.lighthouseapp.com/projects/4819-datamapper/overview
* http://rspec.lighthouseapp.com/

# Getting Started

Before we get started I'm going to assume you have the following installed:

* [Ruby](http://www.ruby-lang.org/) 
* A DBMS (we'll use [MySQL](http://mysql.org/))
* [SVN](http://subversion.tigris.org/) and [git](http://git.or.cz/) (if you want to get the source code)


## Installing Merb

If you just want to play around with Merb grab the gem:
    
    sudo gem install merb -y
    
*Windows users see [this post](http://www.ghostonthird.com/2007/11/17/merb-on-windows-it-works/) for the install instructions.*
    
On the other hand if you want to get down and dirty it's best to grab the source code from trunk 
and you'll need to install the following gems:

    sudo gem install mongrel json_pure erubis mime-types rspec hpricot \
        mocha rubigen haml markaby mailfactory ruby2ruby -y

    (TODO) - git repo for merb trunk 
    svn co http://svn.devjavu.com/merb/trunk merb && cd merb && rake install

Take note that if you need to use JSON you should install the json gem, json_pure is used so merb will install on JRuby.

Merb is ORM agnostic, but as the title of this book suggests we'll be using Datamapper.
Should you want to stick with ActiveRecord or play with Sequel, check the [merb documentation](http://merb.rubyforge.org/files/README.html) for install instructions.

## Installing Datamapper

    sudo gem install merb_datamapper
    sudo gem install data_objects
    sudo gem install do_mysql || do_sqlite3 || do_postgres

You need to install the correct database adaptor for the database you are using. I'll use MySQL, 
but you can use any of the above. If you get the following error message, 'Cannot find mysql_config in 
your path', then you need to add your MySQL bin directory to your path or you can run this is the command:

    sudo env PATH=/usr/local/mysql/bin:$PATH gem install pkg/ 
    do_mysql-0.2.2.gem -- --with-mysql-dir=/usr/local/mysql

    # If updating the gem:
    sudo env PATH=/usr/local/mysql/bin:$PATH gem update do_mysql -- \
        --with-mysql-dir=/usr/local/mysql

## Install RSpec

To install the gem, or get the source from trunk:

    gem install rspec
    svn checkout http://rspec.rubyforge.org/svn/trunk rspec_trunk
    



# Creating an App

Right now that we've got all of that installed, time to create some test Merb application. Merb follows the same naming convention for projects that rails does, so 'my\_test\_app' and 'Test2' for example are valid names but 'T 3' is not, as they need to be valid SQL table names.

I like to keep my projects in different directories, so I have a different folder for my Merb apps and 
Rails apps (but it's up to you). So at the command line type:

    mkdir merb
    cd merb
    merb example_one
    
This will generate an empty Merb app, so lets go in and take a look. You'll notice that the directory structure is similar to Rails, with a few differences.

    # expected output
    create  
    create  app/controllers
    create  app/models
    create  app/helpers
    create  app/mailers/helpers
    create  app/mailers/views/layout
    create  app/parts/helpers
    create  app/parts/views/layout
    create  app/views/layout
    create  app/views/exceptions
    create  config/environments
    create  lib
    create  log
    create  public/images
    create  public/javascripts
    create  public/stylesheets
    create  script
    create  spec/models
    create  spec/controllers
    create  test/unit
    create  gems
    create  Rakefile
    create  app/controllers/application.rb
    create  app/controllers/exceptions.rb
    create  app/helpers/global_helper.rb
    create  app/parts/views/layout/application.html.erb
    create  app/mailers/views/layout/application.html.erb
    create  app/mailers/views/layout/application.text.erb
    create  app/views/layout/application.html.erb
    create  app/views/exceptions/internal_server_error.html.erb
    create  app/views/exceptions/not_found.html.erb
    create  app/views/exceptions/not_acceptable.html.erb
    create  public/images/merb.jpg
    create  public/stylesheets/master.css
    create  public/merb.fcgi
    create  config/boot.rb
    create  config/merb_init.rb
    create  config/router.rb
    create  config/upload.conf
    create  config/dependencies.rb
    create  config/environments/development.rb
    create  config/environments/production.rb
    create  config/environments/test.rb
    create  spec/spec_helper.rb
    create  test/test_helper.rb
    create  config/merb.yml
    create  script/stop_merb
    create  script/generate
    create  script/destroy
    

    
## Configuring Merb

Right so lets try and get the server running, before we do that you'll need to edit the dependencies.rb 
file so un-comment the following lines (this is only necessary if you need to connect to a database):

config/dependencies.rb
    
    use_orm :data_mapper

    use_test :rspec

    dependencies "RedCloth", "merb_helpers"
      

Typing merb now in your command line will try and start the server.

    Started merb_init.rb ...
    No database.yml file found in /Users/work/merb/t/example_one/config.
    A sample file was created called database.sample.yml for you to copy and edit.

As you can see, we forgot to set up the database. A sample file has kindly been generated for us. 
So create a database.yml file a bit like this one (remember to create the database you specify):

    # This is a sample database file for the DataMapper ORM
    :development:
      :adapter: mysql
      :database: test
      :username: root
      :password: 
      :host: localhost

      
Starting merb again shows everything is running ok:

    Merb started with these options:
    --- 
    :exception_details: true
    :query_string_whitelist: []

    :port: "4000"
    :environment: development
    :session_secret_key: /USERS/WORK/BOOK/MERB_BOOK/CODE/EXAMPLE_ONE2400
    :reloader_time: 0.5
    :host: 0.0.0.0
    :mongrel_x_sendfile: true
    :reloader: true
    :cache_templates: false
    :use_mutex: true
    :merb_root: /Users/work/book/merb_book/code/example_one
    :session_id_cookie_only: true

    Started merb_init.rb ...
    Connecting to database...
    Loading Application...
    Compiling routes..
    Loaded DEVELOPMENT Environment...
    Not Using Sessions

You'll notice Merb runs on port 4000, but this can be changed with flag -p [port number]. More options can be found by typing:

    merb --help


# The Framework

Lets take a closer look at the directory structure that we've just created. I'll give brief overview of the framework here and go into further details of each component in subsequent chapters.

(TODO) - book:publish to add image
![Directory Stucture](dir.jpg)

The app folder contains your usual Models, Views and Controllers, Helpers. It also has Parts (they inherit from AbstractController), similar to the old Rails components, but are lightweight and are useful for sidebars, widgets etc. Mailers (which also inherit from the AbstractController) have their own folder where the controllers and views live. 

    app
      |--- controllers
      |--- models
      |--- helpers
      |--- mailers
      |--- helpers
      |--- parts
      |--- views

The config folder has all the configuration files and environments. It's important to edit the following files in here, dependencies.rb and database.yml before running Merb. The Merb router is defined here too, which map the incoming requests to the controllers (the syntax is not the same as Rails). 

    config
         \--- environments

Lib Folder contains extra stuff, not necessarily loaded on boot, need to add to dependencies. 

(TODO) - better lib desc, loading files etc
    
    lib
    
The Log directory contains logs, process id's.
    
    log
    
Public will hold all your assets, just like rails. 
    
    public
          \--- images
          \--- javascripts
          \--- stylesheets
    
Script contains the generators and scripts. Run script/generate --help to see what generators you have available. 
    
    script
    
Spec is for RSpec tests.
    
    spec
        \--- models
        \--- controllers
    
Test is for test/unit (same as Rails)
    
    test
        \--- unit
        
Gem is there so you can package gems with your application, as plug-ins are gems 
    
    gems
    
 
Unlike Rails there is no db, doc or vendor directory when generating an empty app.
# A little blog

In the examples we'll be developing a small blogging application. It's a good idea to grab the source code from 
(TODO) -location, so you can follow along with the examples.

First of all let's define some of the functionality we would expect from any blogging application. 

* Publishing posts
* Leaving comments
* Sending email notifications
* Attaching images
* Authentication

Lets get started with out application:

    merb simple_blog

We're going to use the Linguistics gem so you'll need to install it.
(TODO) - linguistics gem install

Set up the configuration files as before:

config/dependencies.rb

    use_orm :data_mapper

    use_test :rspec

    dependencies "RedCloth", "merb_helpers"
    dependencies 'linguistics'
    
Now add a config/database.yml file with the following:

    ---
    :development: &defaults
      :adapter: mysql
      :database: simple_blog
      :username: root
      :password: 
      :host: localhost

    :test:
      <<: *defaults
      :database: simple_blog_test

    :production:
      <<: *defaults
      :database: simple_blog_production
      
Now we're ready to rock and roll ...
## Models

### Getting started

Having discussed the functionality we can deduce that we will need the following models, Post, Comment, Tag, User and Image.

Merb has a model generator just as rails does:

    script/generate model post

This is make a post model for you, provided that you have defined an orm and the database simple_blog, in the previous steps.

When you run rake dm:db:auto_migrate, it will create the database table and all the properties, but take care this is a destructive method!

You can set the name of the database table in your model if it is called something different with:

    set_table_name 'list_of_posts'
    
This is only necessary if you are using an already existing database.

#### Properties

So DM models differ a bit from AR models as previously stated. Defining the database columns is achieved with the property method.

app/models/post.rb

    property :title,      :string,    :lazy => false
    
This is the title property of the post model. As we can see, the parameters are the name of the table column followed by the type and finally the options. 

Some of the available options are:

    :lazy         - Lazy load the specified property (:lazy => true).
    :default      - Specifies the default value
    :column       - Specifies the table column
    :nullable     - Can the value be null?
    :key          - Set as primary key
    :index        - Creates a database index for the column
    :accessor     - Set method visibility for the property accessors. Affects both
                    reader and writer. Allowable values are :public, :protected, :private.
    :reader       - Like the accessor option but affects only the property reader.
    :writer       - Like the accessor option but affects only the property writer.
    :protected    - Alias for :reader => :public, :writer => :protected
    :private      - Alias for :reader => :public, :writer => :private


#### Associations

Like AR, DM has associations which define relationships between models. Continuing with the Post model we can see a few of the associations defined:
    
    has_many :comments
    belongs_to :author, :class => 'User', :foreign_key => 'author_id'
    
You also can have the associations, has\_one and has\_and\_belongs\_to\_many (where you can specify the :join_table).
    
Pretty straight forward. A few things you should note however, you do not need to specify the foreign key as a property if it's defined in the association, and currently has\_one is implemented as has\_many (so it returns an array with one object instead of just the object itself, but this is will likely change!).

You also don't have to specify a relationship at all if you don't want to, as models can have one way relationships.

##### Polymorphic associations
http://pastie.textmate.org/private/mrvx3qmuagypwukrri9jq
(TODO) -polly assoc

##### Where is my has\_many :through?!
has\_many :through is in the pipes, but it is not currently available in DM. You could write your own methods, which mimicked that behaviour.
    
    (TODO) -example for hmthrough
 
#### Validation

(TODO) - custom validation, and vaildable gem

#### Callbacks

(TODO) list of available call backs


#### Migrations

(TODO) - maybe mention migrations

### CRUD

(TODO) -CRUD

#### Creating
To create a new record, just call the method new on a model and pass it your attributes.

    @post = Post.new(:title => 'My first post')
    
There is also an AR like method to find\_or\_create which attempts to find an object with the attributes provided, and creates the object if it cannot find it.

There is another way to create an object, which is to save it after the attributes have been set like this:
   
    @post = Post.new
    @post.attributes = {:name => 'Hi!',:body => 'This is just awesome!'}
    @post.save
    
#### Reading (aka finding)

The syntax for retrieving data from the database is clean an simple. As you can see with the following examples.

Finding a post with one as its primary key is done with the following:

    Post[1]
 
To get an array of all the records for the post model:

    Post.all

*NOTE*: you can also do Post.find(:all), like the AR syntax but this is just a synonym for Post.all

To get the first post, with the condition author = 'Matt':

    Post.first(:author => 'Matt')

When retrieving data the following parameters can be used:

    #   Posts.all :order => 'created_at desc'              # => ORDER BY created_at desc
    #   Posts.all :limit => 10                             # => LIMIT 10
    #   Posts.all :offset => 100                           # => OFFSET 100
    #   Posts.all :include => [:comments]

If the parameters are not found in these conditions it is assumed to be an attribute of the object.

You can also use symbol operators with the find to specify a condition, for example:

    Posts.all :title.like => '%welcome%', :created_at.lt => Time.now

This would return all the posts, where the tile was like 'welcome' and was created in the past.

Here is a list of the valid operators:

* gt    - greater than
* lt    - less than
* gte   - greater than or equal
* lte   - less than or equal
* not   - not equal
* like  - like
* in    - will be used automatically when an array is passed in as an argument
    
If you require a custom find, you can use sql with the method, find\_by\_sql. This will return an array of Structs (which are read-only) with the result of the query. 

##### Count

DM provides a count method to count the number of records of a model, you can also pass search conditions to count:

    comment_count = Post[1].comments.count
    
##### Each

(TODO) - Each

DataMapper sports an incredibly powerful each method with safely iterates over large quantities of rows in a table performing the block you pass in. Think of it like a Animal.find(:all).each {} block, but so much easier on your resources. Rather than instantiating all objects and then iterating over them, each works in batches and only instantiates a batch of results at a time, then iterates over items in the batch. Notice how you can pass it options just like a finder.

    1 Animal.each(:species => 'Mammal').each do |a|
    2   a.reproduce!
    3 end

#### Updating

    1 zoo.update_attributes(:name => 'Funky Town Municipal Zoo')


(TODO) - updating attributes
(TODO) - Dirty? only updates the changed attributes, so take note for virtual attrs

#### Destroying

You can destroy database records with the method destroy!, this work much like AR.
 
    bad_comment = Comment[6]
    bad_comment.destroy!
    
Should you want to delete all the records of a model, you can do the following:

    Comment.delete_all





## Routing

(TODO) - Defining routes, and resources
(TODO) - Nested routes
(TODO) - Namespaces
(TODO) - Show routes, merb.show_routes in merb's irb console (merb -i)
## Controllers

(TODO) - filters, how the chaining works and :throw
(TODO) - how params get passed in controllers
(TODO) - usecase for a part, explain what they are (possibly comments?) - or a side bar of some sorts
(TODO) - Admin controller
(TODO) - Exception Controller
(TODO) - specify a layout
(TODO) - rest
(TODO) - content_type
(TODO) - flash?
## Views

(TODO) - form helpers
(TODO) - mention you can use other template languages

### Partials

Use the partial method to render a partial from the current directory. If you pass a hash as the second argument the contents will be made available as local variables in the partial.

    partial :post, {:comments => @post.comments}

To display the latest posts on our blog's front page, we use the :with and :as arguments to render a collection.

    partial :post, :with => @posts, :as => post
## Mailers

(TODO) - sending mail
(TODO) - mail templates in /views
## Authentication

(TODO) - Rolling your own
(TODO) - integrating RESTful auth (merbful)
## Attachments

(TODO) - attachment_pu
(TODO) - image resize/crop
(TODO) - downloading
# RSpec

When using stubs with RSpec you can roughly categorise the methods you are going to use into two categories. On one side you have the sub! and should_receive methods which refine what methods you expect to be called with what parameters and potentially what they should return in the case of the test being run. On the other side you have assertions which test the output and value or variables. The should method is primarily used when asserting things.

### What is it?

(TODO) - BDD

### Why test?

(TODO) benefits of testing

### What to test?

(TODO) - how to write good test and what should just trust works

## mocking

(TODO) - What is it and why mock
## Helpers

(TODO) - what should you use helpers for?
## Spec'ing Models

(TODO) - How to spec models, use example merb/dm test talk through them, mocking
## Spec'ing Views

(TODO) - What they should test
## Spec'ing Controllers

### Getting started

Testing controllers typically involves stubbing out some methods, making a fake request and then ensuring the right variables are assigned, exceptions are raised and views rendered.

A good start is testing the show action in our Posts controller.

    class Posts < Application
      provides :html
  
      def show(id)
        @post = Post[id]
        render @post
  
        rescue DataMapper::ObjectNotFoundError
        raise NotFound
      end
    end

Our first test will ensure that Post[1] is called when /posts/1 is visited, and when the post exists the response code is 200 OK.

    describe Posts, "show action" do
      it "should find post and render show view" do
        Post.should_receive(:[]).with("1")
        get('/posts/1', :yields => :controller) do
          controller.stub!(:render)
        end
        status.should == 200
      end
    end

The first should_receive ensures that Post[1] is called, we could mock out a Post instance to return here, but in this case we're only interested in it being called and not raising an exception.

Next we use the get method to make a request to the controller, the :yields option allows us to set what the get request returns. Here we want to grab the controller and then stub out the render method before the request is made. Anything inside you get method's block will be executed before the request is dispatched.

After the request has been dispatched, several methods are available to return the results from the request: body, status, params, cookies, headers, session, response and route. Note that these all just call the same method on controller (so status is the same as controller.status).

This test was fairly simple, and it's likely you won't need to such tests if your controllers are as simple as ours. But once you have more than a few lines in your controller, simple response status checks can be useful for ensuring the overall integrity of your app.

A more important test would be ensuring that a 404 is returned when the post cannot be found in the database. When Datamapper cannot find a record is raises Datamapper::ObjectNotFoundError. Merb has several useful exception classes which will set the correct status and then call the relevant action in your Exceptions controller. Raising NotFound will set the status to 404 and then call the not_found action, which can return a much nicer.

    it "should return 500 if post doesn't exist" do
      post = mock(Post)
      Post.should_receive(:[]).with("1").and_raise(DataMapper::ObjectNotFoundError)
      get('/posts/1')
      status.should == 404
    end

Unlike the last test there was no need for us to stub the render method because DataMapper::ObjectNotFoundError is raised before it is reached.

### Testing multipart forms

(TODO: Make and example of uploading assets in the simple blog)

The multipart_post method allows you to include files in a fake request. There must however be an actual file to be opened and submitted. If you put the file in the same directory as your spec, use File.dirname(__FILE__) to ensure the full path is used.

If you are going to open the tempfile which is uploaded, remember to stub out File.open. Watch out though, if you use simply open instead of File.open it won't be the File.open you stubbed out. The other issue here is within the spec we have no way of knowing what the filename of the tempfile is, so we have to assume it's correct and use an_instance_of(String) so any filename is accepted.

(TODO: test code)

    describe Posts, "create action" do 
        it "should receive file" do
          File.should_receive(:open).with(an_instance_of(String))
          multipart_post("/posts", {:image => File.open(File.join( File.dirname(__FILE__), "picture.jpg"))})
          controller.assigns(:filename).should == "picture.jpg"
        end
    end

Your controller would look something like this.

    class Posts < Application
        def create
            fp = File.open(params[:image][:tempfile].path)
            @filename = params[:image][:filename]
        end
    end
## Caching

(TODO) - session cache
(TODO) - Query/Mem cache

# Gotchas

## Merb
(TODO) - Merb/Rails diffs

## DataMapper
(TODO) - DM / AR diffs

## RSpec

(TODO) - Test:Unit / RSpec diffs
# Submitting a patch
http://www.gweezlebur.com/2008/2/1/so-you-want-to-contribute-to-merb-core-part-1

(TODO) - example patch

### Diffs
(TODO) - where to send diffs

### Docs
(TODO) - doc convention

### Specs
(TODO) - write specs
# Hacking Merb
(TODO) - Hacking Merb

## 

## Changing the directory structure

    # Build the framework paths.
    #
    # By default, the following paths will be used:
    # application:: Merb.root/app/controller/application.rb
    # config:: Merb.root/config
    # lib:: Merb.root/lib
    # log:: Merb.root/log
    # view:: Merb.root/app/views
    # model:: Merb.root/app/models
    # controller:: Merb.root/app/controllers
    # helper:: Merb.root/app/helpers
    # mailer:: Merb.root/app/mailers
    # part:: Merb.root/app/parts
    #
    # To override the default, set Merb::Config[:framework] in your initialization file.
    # Merb::Config[:framework] takes a Hash whose key is the name of the path, and whose
    # values can be passed into Merb.push_path (see Merb.push_path for full details).
    #
    # ==== Note
    # All paths will default to Merb.root, so you can get a flat-file structure by doing
    # Merb::Config[:framework] = {}
    # 
    # ==== Example
    # {{[
    #   Merb::Config[:framework] = {
    #     :view => Merb.root / "views"
    #     :model => Merb.root / "models"
    #     :lib => Merb.root / "lib"
    #   }
    # ]}}
    # 
    # That will set up a flat directory structure with the config files and controller files
    # under Merb.root, but with models, views, and lib with their own folders off of Merb.root.
    class Merb::BootLoader::BuildFramework < Merb::BootLoader
      class << self

        def run
          build_framework
        end
  
        # This method should be overridden in merb_init.rb before Merb.start to set up a different
        # framework structure
        # DOC: Yehuda Katz FAILED
        def build_framework
          unless Merb::Config[:framework]
            %w[view model controller helper mailer part].each do |component|
              Merb.push_path(component.to_sym, Merb.root_path("app/#{component}s"))
            end
            Merb.push_path(:application,  Merb.root_path("app/controllers/application.rb"))
            Merb.push_path(:config,       Merb.root_path("config"), nil)
            Merb.push_path(:environments, Merb.dir_for(:config) / "environments", nil)
            Merb.push_path(:lib,          Merb.root_path("lib"), nil)
            Merb.push_path(:log,          Merb.log_path, nil)
            Merb.push_path(:public,       Merb.root_path("public"), nil)
            Merb.push_path(:stylesheet,   Merb.dir_for(:public) / "stylesheets", nil)
            Merb.push_path(:javascript,   Merb.dir_for(:public) / "javascripts", nil)
            Merb.push_path(:image,        Merb.dir_for(:public) / "images", nil)        
          else
            Merb::Config[:framework].each do |name, path|
              Merb.push_path(name, Merb.root_path(path.first), path[1])
            end
          end
        end
      end
    end



# Deploying a Merb App

(TODO) - get ben32 stuff on this
